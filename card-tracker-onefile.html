<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Card Tracker (One‑File)</title>
  <style>
* { box-sizing: border-box; }
body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  margin: 0;
  background: #f7f7f7;
  color: #222;
}
header { position: sticky; top: 0; z-index: 10; background: #fff; border-bottom: 1px solid #e0e0e0; padding: 8px 10px; }
h1 { margin: 6px 0 8px; text-align: center; font-size: 20px; }
.toolbar { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
button, select { font: inherit; padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
button:active { transform: scale(0.98); }
main { padding: 12px; max-width: 1100px; margin: 0 auto; }
.output { white-space: pre-wrap; background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin: 8px auto 12px; max-height: 220px; overflow: auto; }
.deck { background: #fff; border: 1px solid #ddd; border-radius: 10px; padding: 10px; margin: 12px 0; }
.deck-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.deck-name { font-weight: 700; font-size: 16px; padding: 4px 8px; border-radius: 6px; }
.deck-name[contenteditable="true"] { outline: 2px dashed #c9c9c9; }
.card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; }
.card { border: 1px solid #d0d0d0; border-radius: 8px; background: #fafafa; padding: 8px; display: flex; align-items: center; gap: 6px; min-height: 44px; }
.card .name { flex: 1; padding: 4px 6px; border-radius: 6px; }
.card .name[contenteditable="true"] { background: #fff3cd; outline: 1px dashed #c9a600; }
.badge { font-size: 12px; padding: 2px 6px; border-radius: 999px; border: 1px solid #ccc; background: #fff; }
.btn { font-size: 12px; padding: 4px 6px; border-radius: 6px; border: 1px solid #ccc; background: #fff; }
.status-needed { background: #ffe9e9; border-color: #ffb7b7; }
.status-duplicate { background: #e9f5ff; border-color: #b7dcff; }
.status-owned { background: #ecffe9; border-color: #b9f3b0; }
.gold { background: gold !important; border-color: #caa300 !important; color: #222; }
.gold .badge { background: rgba(255,255,255,0.8); border-color: #caa300; }
.card-footer { display: flex; gap: 6px; align-items: center; justify-content: flex-end; }
.small { color: #666; font-size: 12px; }
dialog { border: none; border-radius: 12px; width: min(700px, 96vw); padding: 0; }
.dialog-form { padding: 16px; }
dialog::backdrop { background: rgba(0,0,0,0.3); }
#translationRows { display: grid; grid-template-columns: 1fr 1fr auto; gap: 8px; margin: 8px 0 12px; }
#translationRows input { padding: 8px; border-radius: 8px; border: 1px solid #ccc; }
#restoreTextarea { width: 100%; border-radius: 8px; border: 1px solid #ccc; padding: 8px; }
@media (hover: none) { .badge, .btn { padding: 6px 8px; } }
  </style>
</head>
<body>
  <header>
    <h1>Card Tracker</h1>
    <div class="toolbar">
      <button id="exportDuplicatesBtn">Export Duplicates</button>
      <button id="exportNeededBtn">Export Needed</button>
      <button id="copyOutputBtn">Copy Output</button>
      <select id="filterSelect" aria-label="Filter cards">
        <option value="all">Show: All</option>
        <option value="needed">Needed</option>
        <option value="duplicate">Duplicate</option>
        <option value="owned">Owned</option>
        <option value="gold">Gold (Unsharable)</option>
      </select>
      <button id="openTranslationsBtn">Translations</button>
      <button id="backupBtn">Backup JSON</button>
      <button id="restoreBtn">Restore JSON</button>
      <button id="resetBtn">Reset</button>
    </div>
  </header>

  <main>
    <div id="output" class="output" aria-live="polite"></div>
    <div id="deck-container"></div>
  </main>

  <!-- Translation Modal -->
  <dialog id="translationsDialog">
    <form method="dialog" class="dialog-form">
      <h2>Translation Map (Foreign → English)</h2>
      <p class="small">
        When exporting lists, card names are translated to English if a mapping exists.
        Example: <code>Playa → Beach</code>
      </p>
      <div id="translationRows"></div>
      <div class="row">
        <input id="newForeign" placeholder="Foreign name (as typed)" />
        <input id="newEnglish" placeholder="English name" />
        <button id="addTranslationBtn" type="button">Add</button>
      </div>
      <menu>
        <button id="clearTranslationsBtn" type="button">Clear All</button>
        <button id="closeTranslationsBtn" value="cancel">Close</button>
      </menu>
    </form>
  </dialog>

  <!-- Restore Modal -->
  <dialog id="restoreDialog">
    <form method="dialog" class="dialog-form">
      <h2>Restore from JSON</h2>
      <textarea id="restoreTextarea" rows="10" placeholder='Paste your backup JSON here'></textarea>
      <menu>
        <button id="confirmRestoreBtn" type="button">Restore</button>
        <button value="cancel">Cancel</button>
      </menu>
    </form>
  </dialog>

  <script>
/***** STORAGE KEYS *****/
const STORAGE_KEY = 'cardTrackerData.v1';
const TRANSLATE_KEY = 'cardTrackerTranslations.v1';

/***** INITIAL DATA: 15 decks × 9 cards *****/
function makeDefaultDecks() {
  const defaultNames = [
    "Deck 1","Deck 2","Deck 3","Deck 4","Deck 5",
    "Deck 6","Deck 7","Deck 8","Deck 9","Deck 10",
    "Deck 11","Deck 12","Deck 13","Deck 14","Deck 15"
  ];
  return defaultNames.map((n) => ({
    name: n,
    cards: Array.from({ length: 9 }, (_, i) => ({
      name: \`Card \${i+1}\`,
      status: "owned" // needed | duplicate | owned | gold
    }))
  }));
}

/***** STATE *****/
let decks = loadJSON(STORAGE_KEY) ?? makeDefaultDecks();
let translationMap = loadJSON(TRANSLATE_KEY) ?? {}; // { foreignName: "English Name" }
let currentFilter = 'all'; // all | needed | duplicate | owned | gold

/***** UTILITIES *****/
function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(decks)); }
function saveTranslations() { localStorage.setItem(TRANSLATE_KEY, JSON.stringify(translationMap)); }
function loadJSON(key) {
  try { const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : null; }
  catch { return null; }
}
function slugStatus(status) { return status === 'gold' ? 'gold' : \`status-\${status}\`; }
function translateName(name) {
  const key = name.trim();
  return translationMap[key] && translationMap[key].trim() ? translationMap[key].trim() : name;
}

/***** RENDERING *****/
const deckContainer = document.getElementById('deck-container');
const outputEl = document.getElementById('output');

function render() {
  deckContainer.innerHTML = '';
  decks.forEach((deck, deckIndex) => {
    const section = document.createElement('section');
    section.className = 'deck';

    const header = document.createElement('div');
    header.className = 'deck-header';

    const nameEl = document.createElement('div');
    nameEl.className = 'deck-name';
    nameEl.contentEditable = 'true';
    nameEl.textContent = deck.name;
    nameEl.addEventListener('blur', () => {
      decks[deckIndex].name = nameEl.textContent.trim() || \`Deck \${deckIndex+1}\`;
      save();
    });

    header.appendChild(nameEl);
    section.appendChild(header);

    const grid = document.createElement('div');
    grid.className = 'card-grid';

    deck.cards.forEach((card, cardIndex) => {
      if (currentFilter !== 'all' && currentFilter !== card.status) return;

      const cardEl = document.createElement('div');
      cardEl.className = \`card \${slugStatus(card.status)}\`;
      if (card.status === 'gold') cardEl.classList.add('gold');

      const nameSpan = document.createElement('div');
      nameSpan.className = 'name';
      nameSpan.contentEditable = 'true';
      nameSpan.textContent = card.name;
      nameSpan.title = 'Tap to edit name';
      nameSpan.addEventListener('blur', () => {
        decks[deckIndex].cards[cardIndex].name = nameSpan.textContent.trim() || \`Card \${cardIndex+1}\`;
        save();
      });

      const badge = document.createElement('span');
      badge.className = 'badge';
      badge.textContent = card.status === 'gold' ? 'Unsharable' : card.status[0].toUpperCase() + card.status.slice(1);

      const footer = document.createElement('div');
      footer.className = 'card-footer';

      const toggleGoldBtn = document.createElement('button');
      toggleGoldBtn.className = 'btn';
      toggleGoldBtn.textContent = card.status === 'gold' ? 'Ungold' : 'Gold';
      toggleGoldBtn.title = 'Toggle Gold (Unsharable)';
      toggleGoldBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        decks[deckIndex].cards[cardIndex].status = (card.status === 'gold') ? 'owned' : 'gold';
        save(); render();
      });

      const cycleBtn = document.createElement('button');
      cycleBtn.className = 'btn';
      cycleBtn.textContent = 'Cycle';
      cycleBtn.title = 'Needed → Duplicate → Owned';
      cycleBtn.disabled = card.status === 'gold';
      cycleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        cycleStatus(deckIndex, cardIndex);
      });

      footer.appendChild(toggleGoldBtn);
      footer.appendChild(cycleBtn);

      cardEl.addEventListener('click', () => { if (card.status !== 'gold') cycleStatus(deckIndex, cardIndex); });

      cardEl.appendChild(nameSpan);
      cardEl.appendChild(badge);
      cardEl.appendChild(footer);
      grid.appendChild(cardEl);
    });

    section.appendChild(grid);
    deckContainer.appendChild(section);
  });
}

function cycleStatus(deckIndex, cardIndex) {
  const order = ['needed', 'duplicate', 'owned'];
  const card = decks[deckIndex].cards[cardIndex];
  if (card.status === 'gold') return;
  const i = order.indexOf(card.status);
  const next = order[(i + 1) % order.length];
  decks[deckIndex].cards[cardIndex].status = next;
  save(); render();
}

/***** EXPORTS *****/
function exportList(kind) {
  const lines = [];
  decks.forEach((deck) => {
    const items = deck.cards
      .filter(c => c.status === kind && c.status !== 'gold')
      .map(c => translateName(c.name));
    if (items.length) lines.push(\`\${deck.name.toUpperCase()} - \${items.join(', ')}\`);
  });
  const text = lines.join('\n');
  outputEl.textContent = text || \`(No \${kind}s found)\`;
  return text;
}

/***** BACKUP / RESTORE *****/
function backupJSON() {
  const payload = { version: 1, decks, translations: translationMap };
  const text = JSON.stringify(payload, null, 2);
  outputEl.textContent = text;
}
function openRestore() {
  document.getElementById('restoreTextarea').value = '';
  document.getElementById('restoreDialog').showModal();
}
function confirmRestore() {
  const raw = document.getElementById('restoreTextarea').value.trim();
  if (!raw) return;
  try {
    const obj = JSON.parse(raw);
    if (!obj.decks || !Array.isArray(obj.decks)) throw new Error('Invalid JSON');
    decks = obj.decks;
    translationMap = obj.translations || {};
    save(); saveTranslations();
    document.getElementById('restoreDialog').close();
    render();
    outputEl.textContent = 'Restored from JSON.';
  } catch (e) {
    alert('Restore failed: ' + e.message);
  }
}

/***** TRANSLATIONS UI *****/
function openTranslations() {
  const rows = document.getElementById('translationRows');
  rows.innerHTML = '';
  Object.entries(translationMap).forEach(([foreign, english]) => addTranslationRow(rows, foreign, english));
  document.getElementById('translationsDialog').showModal();
}
function addTranslationRow(container, foreign, english) {
  const f = document.createElement('input'); f.value = foreign; f.placeholder = 'Foreign name';
  const e = document.createElement('input'); e.value = english; e.placeholder = 'English name';
  const del = document.createElement('button'); del.textContent = '✕'; del.className = 'btn';
  del.addEventListener('click', () => { delete translationMap[foreign]; saveTranslations(); container.removeChild(row); });
  const row = document.createElement('div'); row.className = 'row'; row.style.display = 'contents';
  f.addEventListener('blur', () => { if (foreign !== f.value) { delete translationMap[foreign]; foreign = f.value; } if (foreign) translationMap[foreign] = e.value || ''; saveTranslations(); });
  e.addEventListener('blur', () => { if (foreign) translationMap[foreign] = e.value || ''; saveTranslations(); });
  row.appendChild(f); row.appendChild(e); row.appendChild(del);
  container.appendChild(row);
}
function addNewTranslation() {
  const foreign = document.getElementById('newForeign').value.trim();
  const english = document.getElementById('newEnglish').value.trim();
  if (!foreign) return;
  translationMap[foreign] = english || '';
  saveTranslations();
  addTranslationRow(document.getElementById('translationRows'), foreign, english);
  document.getElementById('newForeign').value = '';
  document.getElementById('newEnglish').value = '';
}

/***** FILTER *****/
function setFilter(v) { currentFilter = v; render(); }

/***** COPY *****/
async function copyOutput() {
  const text = outputEl.textContent || '';
  if (!text) return;
  try { await navigator.clipboard.writeText(text); outputEl.textContent += '\n\n(Copied to clipboard)'; }
  catch { prompt('Copy text:', text); }
}

/***** RESET *****/
function hardReset() {
  if (!confirm('Reset all decks to default and clear translations?')) return;
  decks = makeDefaultDecks();
  translationMap = {};
  save(); saveTranslations();
  render();
  outputEl.textContent = 'Reset to default.';
}

/***** WIRE UP *****/
document.getElementById('exportDuplicatesBtn').addEventListener('click', () => exportList('duplicate'));
document.getElementById('exportNeededBtn').addEventListener('click', () => exportList('needed'));
document.getElementById('copyOutputBtn').addEventListener('click', copyOutput);
document.getElementById('filterSelect').addEventListener('change', (e) => setFilter(e.target.value));
document.getElementById('openTranslationsBtn').addEventListener('click', openTranslations);
document.getElementById('backupBtn').addEventListener('click', backupJSON);
document.getElementById('restoreBtn').addEventListener('click', openRestore);
document.getElementById('confirmRestoreBtn').addEventListener('click', confirmRestore);
document.getElementById('resetBtn').addEventListener('click', hardReset);
document.getElementById('addTranslationBtn').addEventListener('click', addNewTranslation);
document.getElementById('closeTranslationsBtn').addEventListener('click', () => { document.getElementById('translationsDialog').close(); });
document.getElementById('clearTranslationsBtn').addEventListener('click', () => {
  if (confirm('Clear ALL translations?')) {
    translationMap = {};
    saveTranslations();
    document.getElementById('translationRows').innerHTML = '';
  }
});

/***** INIT *****/
render();
  </script>
</body>
</html>